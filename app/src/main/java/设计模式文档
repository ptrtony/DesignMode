1 单一职责原则
包名：singleResponsibility
单一职责原则注意事项和细节
1)、降低类的复杂度，一个类只负责一项职责
2)、提高类的可读性，可维护性
3)、降低变更引起的风险
4)、通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则：
只有类中方法数量足够少，可以在方法级别保持单一职责原则

2 接口隔离原则
包名interface_segregation_principle
基本介绍
1)、客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖
应该建立在最小的接口上
2)、类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口
Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法
3)、按隔离原则应当这样处理：
将接口interface拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。
1)、类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说
不是最小接口，那么类B和类D必须去实现他们不需要的方法
2)、将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则
3)、接口Interface1中出现的方法，根据实际情况拆分为三个接口
4)、代码实现

3 依赖倒置原则
包名：dependence_inversion_principle
1)、高层模块不应该依赖底层模块，二者都应该依赖其抽象
2)、抽象不应该依赖细节，细节应该依赖与抽象
3)、依赖倒转(倒置)的中心思想是面向接口编程
4)、依赖倒转原则是基于这样的设计理念，相当于细节的多变性，抽象的东西要稳定的多
以抽象为基础搭建的架构比以细节为基础的架构要稳定的多，在java中，抽象指的是接口或抽象类，细节
就是具体的实现类
5)、使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成
实现方式：
1)、接口传递（应用案例代码）
2)、构造方法传递（应用案例代码）
3)、setter方式传递

4里氏替换原则
包名：liskov
00中的继承性的思考和说明
1)、继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制
要求所有的子类必须遵循这个契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承造成破坏。
2)、继承再给程序设计带来便利的同时，也带来弊端，比如使用继承会给程序带来侵入性，程序的可移植降低，
增加对对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且
父类修改后，所有涉及到子类的功能都有可能产生故障
3)、问题提出：在编程中，如何正确的使用继承?=>里氏替换原则
里氏替换原则是：
1）、如果对每个类型为T1的对象o1，都有类型为T2的对象O2，使得以T1定义的所有程序P在所有的对象O1
都代换成O2时，程序P的行为没有发生改变，那么类型T2是类型T1的子类型，。换句话说，所有引用基类的地方
必须能透明的使用其子类的对象
2)、在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类方法
3)、里氏替换原则告诉我们，继承实际上让两个类耦合性增强，在合适的情况下，可以通过聚合，组合，依赖来解决问题

5开闭原则
包名：open_close
1)、开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则
2)、一个软件实体如类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节
3)、当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化
4)、编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。
思路：把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可，这样我们有新的图形
种类时，只需要让新的图形类继承Shape。并实现draw方法即可。

6迪米特法则
包名：demeter
1)、一个对象应该对其他对象保持最小的了解
2)、类与类关系越密切，耦合度越大
3)、迪米特法则(Demeter principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，也就是说
对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供一个public方法，不对外泄漏任何信息
4)、迪米特法则还是个更简单的定义，只与直接的朋友通讯
5)、直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间时朋友关系，耦合
的方式更多，依赖、关联、组合、聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接朋友，而出现
在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

7合成复用原则
原则是尽量使用合并/聚合的方式，而不是使用继承
设计原则核心思想
1)、找出应用中可能需要变化之处，把它们独立起来，不要和哪些不需要变化的代码混在一起
2)、针对接口编程，而不是针对实现编程
3)、为了交互对象之间的松耦合设计而努力

8单利模式
所谓类的单利模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，
并且该类只提供一个取得其对象实例的方法
比如Hibernate的sessionFactory，它充当数据存储源的代理，并负责创建Session对象，SessionFactory
并不是轻量级的，一般情况下，一个项目通常只需要以恶搞SessionFactory就够，就是就会使用到单例模式
单例模式的八种写法
1)、饿汉式（静态常量）
2)、饿汉式（静态代码块）
3)、懒汉式（线程不安全）
4)、懒汉式（线程安全、同步方法）
5)、懒汉式（线程安全、同步代码块）
6)、双重校验
7)、静态内部类
8)、枚举
饿汉式（静态常量）应用实例
步骤如下：
1)、构造器私有化（防止new）
2)、类的内部创建对象
3)、向外暴露一个静态的公共方法。getInstance
4)、代码实现
优缺点说明：
饿汉式（静态常量）、饿汉式（静态代码块）
Singleton01、Singleton02
1）优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题
2) 缺点：在类装载的时候就完成实例化，没有达到Lazy loading的效果。如果从始至终从未
使用过这个实例，则会造成内存的浪费
3)这种方式基于classloader机制避免了多线程的同步问题。不过，instance在类装载时就
实例化了，在单例模式大多数就是调用getInstance()方法，但是导致类装载的原因有很多种
因此不能确定有其他的方式（或则其他的静态方法）导致类的装载，这时候初始化instance
就没有达到lazy loading的效果
4）结论：这种单例模式可用，可能造成内存浪费
懒汉式（线程不安全）
Singleton03
优缺点
1）、起到了Lazy loading的效果，但是只是在单线程中使用
2）、如果在多线程下，一个线程进入到if(singleton == null) 代码块中
还未来得及往下执行，另一个线程也通过了这个判断条件。这时便会产生多个实例。
所以在多线程环境下不可使用这种方式
3）、结论：在实际的开发中，不要使用这种方式。
懒汉式（线程安全）
Singleton04
优缺点
1）、解决了线程不安全问题
2）、效率太低了，每个线程在想获得类的实例的时候，执行getInstance（）方法都要进行
同步。而其实这个方法只执行了一次实例化代码就够了，后面的想获得该类实例，直接return就行了。
方法进行同步效率太低
3）、结论：在实际的开发中，不推荐使用这种方式。
Singleton05
优缺点
1）、这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，
改为同步产生实例化的代码块
2）、但是这种同步并不能起到线程同步的作用。跟第三种实现方法遇到的情形一致，假如
一个线程进入了if（singleton == null）判断代码块中，还未来得及往下执行，
另一个线程也通过了这个判断语句，这种会产生多个实例。
3）、结论：在实际开发中，不能使用这种方式。
Singleton06
双重检查

Singleton07
优缺点
1）、这种方式采用了类装载机制来保证初始化实例时只有一个线程
2）、静态内部类方法在Singleton类被装载时并不会立即被实例化，而是在需要实例化时，调用
getInstance方法，不会装载SingletonInstance类，而是完成Singleton的实例化
3）、类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程安全
性，在类进行初始化时，别的线程是无法进入的
4）、优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高

9工厂模式
简单工厂模式
1）、简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定
创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式
2）、简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）
3）、在软件开发中，当我们会用到大量的创建某种、某类或则某批对象时，就会使用到工厂模式
工厂方法模式
使用简单工厂模式，创建不同的简单工厂模式，比如BJPizzaSimpleFactory、
LDPizzaSimpleFactory等等，从当前这个案例来说，也是可以的，但是考虑到项目的规模
以及软件的可维护性，可扩展性并不是特别好
思路
使用工厂方法模式
包名：factory/method
工厂方式模式介绍
工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现
工厂方法模式：定义一个创建的抽象方法，由子类决定要实例化的类。工厂方法模式将抽象的实例化推迟给子类。
抽象工厂模式
包名：factory/abs
抽象工厂模式：
1）、定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
2）、抽象工厂模式可以将简单的工厂模式和工厂方法整合
3）、从设计层面看，抽象工厂模式就是对简单的工厂模式的改进（或者称为进一步的抽象）
4）、将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用
对应的工厂子类。这样将单个的简单工厂类变成了工厂簇；便利于代码的维护和扩展

10原型模式
包名：proto_type
传统的方式的优缺点
1）、优点是比较好理解，简单易操作
2）、在创建新的对象时，总是需要获取原始对象的属性，如果创建的对象比较复杂时，效率很低
3）、总是需要重新初始化对象，而不是动态得获取对象运行时的状态，不够灵活
4）、改进的思路
思路：Java中的Object类是所有类的根类，Object类提供了一个clone的方法，该方法可以将一个Java
对象复制一份，但是需要实现clone的Java类实现一个接口Cloneable，该接口表示该类能否复制且具有
复制的能力=>原型模式。
原型模式概念
1）、原型模式（ProtoType模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这种原型，创建新的对象
2）、原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
3）、工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象
拷贝他们自己来实施创建，即对象clone
Client -> ProtoType ->ConCreteProtoType1 -> ConCreteProtoType2
原理结构图说明：
1、ProtoType原型类，声明一个克隆自己的接口
2、ConcreteProtoType：具体的原型类，实现一个克隆自己的操作
3、Client：一个原型对象克隆自己，从而创建一个新的对象（属性一样）
浅拷贝
1）、对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性
值复制一个给新的对象
2）、对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组，某个类的对象等
那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象
的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量对影响到另一个对象的该成员变量值
3）、前面我们克隆羊就是浅拷贝
4）、浅拷贝是使用默认的clone()方法来实现的
sheep = (sheep)super.clone();
原型模式的注意事项
1）、创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
2）、不用重新初始化对象，而是动态地获得对象运行时的状态
3）、如果原始对象发生变化（增加或者减少属性），其它克隆对象也会发生相应的编码，无需修改代码
4）、在实现深拷贝的时候可能需要比较复杂的代码
5）、缺点：需要为每一个类配置一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，
需要修改其源代码，违背了ocp原则

11 建造者模式
包名：builder
需求：
1）需求建房子：这一个过程为打地基，砌墙、封顶
2）房子有各种各样的，比如普通房，高楼，别墅，各种各样的过程虽然一样，但是要求不是相同的
3）请编写程序，完成需求
优缺点
1）、优点是比较好理解，简单易操作
2）、设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展维护不好，也就是说
这种设计方案，把产品（即房子）和创建产品的过程（即：建房子流程）封装在一起，耦合性增强了
3）、解决方案：将产品和产品建造过程解偶=>建造者模式
基本介绍
1）、建造者模式又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别）
使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象
2）、构造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建他们
用户不需要知道内部具体的构造细节
构造者模式的四个角色
1）product（产品角色）：一个具体的产品对象
2）Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口
3）ConcreteBuilder(具体建造者)：实现接口，构建和装配各个部件
4）Director（指挥者）：构建一个使用Builder的接口的对象。它主要是用于创建一个复杂的对象
它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。
建造者注意事项和细节
1）、客户端（使用程序）不必知道产品内部组成部分，将产品本身与产品的创建过程结偶，使得相同的创建过程
可以创建不同的产品对象
2）、每一个具体创建者都相对独立，而与其他具体建造者无关，因此可以很方便的替换具体建造者或增加新的具体
建造者，用户使用不同的具体建造者即可得到不同的产品对象
3）、可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解为不同的方法中，
使得创建过程更加清晰，也更加方便使用程序来控制创建过程
4）、增加新的具体创建者无须修改原来类库的代码，指挥者类针对抽象建造者类编码，
系统扩散方便，符合“开闭原则”
5）、建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，
则不适合使用建造者模式因此其使用范围受到一定的限制
6）、如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得
很庞大，因此在这种情况下，要考虑是否选择建造者模式
7）、抽象工厂VS建造者模式
抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具体不同分类维度的产品组合
采用抽象工厂模式不需要关系构建过程，只关心什么产品由什么工厂即可。而建造者模式则是要求按照指定的
蓝图建造产品，它的主要目的是通过组装零配件而产生一个新的产品。

12 适配器模式
包名：adapter
1）、适配器模式将某个类的接口转换成客户端期望的另外一个接口表示，主的目的是兼容性，让原来
因接口不匹配不能一起工作的两个类可以协同工作，其别名为包装器
2）、适配器模式属于结构性模式
3）、主要分为三类：类适配器模式、对象适配器模式、接口适配器模式
工作原理
1）、适配器模式：将一个类的接口转换成另外一个接口，让原来接口不兼容的类可以兼容
2）、从用户的角度看不到被适配器，是解偶的
3）、用户调用适配器转化出来的目标接口方法，适配器再调用被适配器的相关接口
4）、用户收到反馈结果，感觉只是和u表接口交互
类适配器
类适配器模式介绍
基本介绍：Adapter类，通过继承src类，实现dest接口，完成src->dest的适配
类适配器注意事项和细节
1）、Java是单继承机制，所有类适配器需要继承src类这一点算是缺点，因为要求dest必须是接口，有一定局限性
2）、src类的方法在Adapter中都会暴露出来，也增加了使用的成本
3）、由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了
对象适配器
1）基本思路和类适配器模式相同，只是将Adapter类作为修改，不是继承src类，而是持有src类的实例
以解决兼容性问题。即：持有src类，实现dst类接口，完成src->dst的适配
2）根据“合成复用原则”，在系统中尽量使用关联关系来替换继承关系
3）对象适配器模式是适配器模式常用的一种
对象适配器模式的注意事项和细节
1）对象适配器和类适配器其实算是同一种思想，只不过实现方式不同
根据合成复用原则，使用组合替换继承，所以它解决了类适配器必须继承src的局限问题，也不再要求dst必须是接口
2）使用成本更低，更灵活。
接口适配器
1）适配器模式或缺省适配器模式
2）当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中的每一个方法提供一个默认
实现（空实现），那么该抽象类的子类可有选择的覆盖父类的某些方法来实现需求
3）使用一个接口不想使用其所有的方法的情况

13 桥接模式
包名：bridge
传统方案解决手机操作问题分析
1）扩展性问题（类爆炸），如果我们再增加手机的样式（旋转式），就需要增加各个品牌手机的类，同样如果我们新增
一个手机品牌，也需要在各个手机样式下增加
2）违反单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本
3）解决方案-使用桥接模式
桥接模式：
1）将实现与抽象放在两个不同类层次中，使两个层次可以独立改变
2）是一种结构设计模式
3）Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责
它的主要特点就是把抽象和行为实现分离开来，从而可以保证各部分的独立性以及应对他们的功能扩展
原理图说明：
1）Client类：桥接模式的调用者
2）抽象类（Abstraction）:维护了Implementor/即它的实现类
ConcreteImplementorA...,两者是聚合关系，Abstraction充当桥接类
3）RefindedAbstraction：是Abstraction的抽象子类
4）Implementor：行为实现类的接口
5）ConcreteImplementorA/B：行为的具体实现类
6）从UML图：这里的抽象类和接口是聚合关系，其实调用和被调用的关系。
桥接模式的注意事项和细节
1）实现了抽象和实现部分的分离，从而极大的提供系统的灵活性，让抽象部分和实现部分独立开来，
这有助于系统进行分层设计，从而产生更好的结构化系统
2）对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他的部分由具体业务来完成
3）桥接模式替代多层级继承方案，可以减少子类的个数，降低系统的管理和维护成本
4）桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，
要求开发者针对抽象进行设计和编程
5）桥接模式要起正确识别出来系统中两个独立变化的维度，因此其使用范围有一定的局限性
即需要有这样的应用场景。

14 装饰器模式
包名：decorator
案例：星巴克咖啡订单项目
1）咖啡种类/单品咖啡：Espresso（意大利咖啡）、ShotBlack、LongBlack、Decaf
2）调料：Milk、Soy、Chocolate
3）要求在扩展新的咖啡种类时，具有良好的扩展性，改动方便，维护方便
4）使用OO的来计算不同种类咖啡的费用：客户可以点单品咖啡，也可以单品咖啡+调料组合
分析：
1）Drink是一个抽象类，表示饮料
2）des就是对咖啡的描述，比如咖啡的名字
3）cost()方法的计算费用，Drink类中做成一个抽象类
4）Decaf就是单品咖啡，继承Drink，并实现cost
5）Espresso & Milk就是单品咖啡+调料，这个组合很多
6）问题：这样设计，会有很多类，当我们增加了单品咖啡，或者新增一个调料，类的数量就会倍增
分析二：
前面分析到方案一因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到Drink中
这样就不会造成类数量倍增，从而提高项目的维护性。
装饰者模式的定义
1）动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭yuanze
2）这里提到的动态的将新功能附加到对象和ocp原则，在后面的应用实例上会以代码的形式体现
装饰者模式原理图
1）装饰者就像打包的一个快递
主体：比如：陶瓷、衣服
包装：比如：报纸填充、塑料泡沫、纸板、木板
2）Component
主体：比如类似前面的Drink
3）ConcreteComponent和Decorate
ConcreteComponent：具体的主体，比如面前的各个单品咖啡
Decorator：装饰者、比如调料
4）在如图的Component与ConcreteComponent之间，如果ConcreteComponent类很多，还可以
设计一个缓冲层，将所有共有的部分提取出来，抽象一个类。

15组合模式
包名：composite
案例：看一个学校院系需求
编写程序展示一个学院院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院
一个学院有多个院系
1）将学院看做是学校的子类，系是学院的子类，这种实际上是站在组织大小来进行分层次的
2）实际上我们的要求是，在一个页面中展示出学院的院系组成，一个学校有多个学院，一个学院有多个系，
因此这种方案，不能很好实现的管理操作比如对学院，系的添加、删除和遍历等
3）解决方案：把学校、院、系都看做组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现
管理操作 => 组合模式
基本介绍
1）组合模式，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系
2）组合模式依据树形结构来组合对象，用来表示部分以及整体层次
3）这种类型的设计模式数据结构性模式
4）组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象
组合模式的原理类图
对原理结构图的说明-即（组合模式的角色及职责）
1）Component：这是组合中对象神明接口，在适当的情况下，实现所有类共有的接口默认行为，用于访问和管理Component的子控件
Component可以是抽象类或接口
2）Leaf：在组合模式表示叶子节点，叶子节点没有子节点
3）Composite：非叶子节点，用于存储子部件，在Component接口中实现，子部件的相关操作，比如增加（add），删除（delete）
组合模式的注意事项和细节
1）简化客户端操作，客户端只需要面对一致的对象而不用考虑整体的部分或者节点叶子的问题
2）具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不需要做出任何的改动
3）方便创建出复杂的层级结构，客户端不用理会组合里面的组成细节，容易添加节点或者叶子节点从而创建出复杂的树形结构
4）需要遍历组织结构，或者处理的对象具有树形结构时，非常合适使用组合模式
5）要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式

16外观模式
包名：facade
案例：组建一个家庭影院：
DVD播放器、投影仪、自动屏幕、环绕立体声、爆米花机，要求完成使用家庭影院的功能，其过程为：
1、直接用遥控器：统筹各设备开关
2、开爆米花机
3、放下屏幕
4、开投影仪
5、开音响
6、开DVD，选dvd
7、去拿爆米花
8、调音灯光
9、播放
10、观影结束后，关闭各种设备
传统方式解决影院管理问题分析
1）在ClientTest的main方法中，创建各个子系统的对象，并直接去调用子系统（对象）相关方法
会造成调用过程混乱，没有清晰的过程
2）不利于在ClientTest中，去维护对子系统的操作
3）解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面（比如在高层接口提供的四个方法
ready，play，pause，end），用来访问子系统中的一群接口
4）也就是说，就是通过定义一个一致的接口（界面类），用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生
调用，而不需关心这个子系统的内部细节=>外观模式
外观模式的基本介绍：
1）外观模式（facade），也叫过程模式，外观模式为子系统的一组接口提供一个一致的外界，此模式定义了一个高层
接口，这个接口使得这一子系统更加容易使用
2）外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统
的内部细节。
1 外观模式可以理解为转换一群接口，客户只需要调用一个接口，而不用调用多个接口才能达到目的。比如：在PC上安装软件的时候
经常有一键安装选项（省去选择安装目录、安装的组建等等），还有就是手机的重启功能（把关机和启动合为一个操作）
2 外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用
外观模式的注意事项和细节
1）外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性
2）外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展
3）通过合理的使用外观模式，可以帮助我们更好的划分访问的层次感
4）当系统需要进行分层设计时，可以考虑使用facade模式
5）在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个facade类
来提供遗留系统的比较清晰简单的接口，让新系统与facade类交互，提供复用性
6）不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的

17享元模式
包名：flyweight
案例：小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同
1）有客户要求新闻的形式发布
2）有客户人要求以博客的形式发布
3）有客户希望以微信公众号的形式发布
传统方案解决网站展示项目
1）直接复制粘贴一份，然后根据客户不同要求，进行定制修改
2）给每一网站租用一个空间
3）方案设计示意图
问题分析：
1）需要的网站结构相似度高，而且都不是高访问网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费
2）解决思路：整合到一个网站中，共享其相关代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少u武器资源
3）对于代码来说，由于是一份实例，维护和扩展都更加容易
4）上面的解决思路时可以使用享元模式来解决
享元模式基本介绍
1）享元模式也叫蝇量模式：运用共享技术有效地支持大量细粒度的对象
2）常用于系统底层开发，解决系统的性能问题，像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则
直接拿来用，避免重新创建，如果我们需要的，则创建一个
3）享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时，不需总是创建新对象，可以从
缓冲池里拿，这样可以降低系统内存，同时提高效率
4）享元模式经典的应用场景就是池技术，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式
对原理图的说明
1）FlyWeight是抽象的享元模式，他是产品的抽象类，同时定义出对象的外部状态和内部状态（后面介绍）的接口和实现
2）ConcreteFlyWeight是具体的享元模式，是具体的产品类，实现抽象角色定义的相关类
3）UnSharedConcreteFlyWeight是不可享元的角色，一般不会出现在享元工厂
4）FlyWeightFactory享元工厂，用于创建一个池容器（集合），同时提供从池中获取对象方法
内部状态和外部状态
比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子
的内部状态；而各种棋子之间的差别都是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是
棋子的外部状态
1）享元模式提出了两个要求；细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：内部状态和外部状态
2）内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变
3）外部状态指对象得以依赖的一个标记，是随环境改变而改变的，不可共享的状态
4）举个例子：围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难
支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了
对象的开销问题
享元模式的注意事项和细节
1）在享元模式这样的理解，“享”就是共享，“元”就是对象
2）系统中有大量的对象，这些对象消耗了大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式
3）用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储
4）享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率
5）享元模式提高了系统的复杂度。需要分离内部和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，
这是我们使用享元模式需要注意的地方
6）使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制
7）享元模式经典的应用场景是需要缓冲池的场景，比如String常量池，数据库的连接池

18代理模式
包名：proxy
1）为一个对象提供替身，以控制这个对象的访问，即通过代理对象访问目标对象，这样做的好处是：可以在目标对象实现
的基础上，增强额外的功能操作，即扩展目标对象的功能
2）被代理的对象可以是远程对象，创建开销大的对象或需要安全控制的对象
3）代理模式有不同的形式，主要有三种 静态代理、动态代理和Cglib代理
静态代理模式的基本介绍
静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类
应用案例
1）定义一个接口：ITeacherDao
2）目标对象TeacherDao实现接口ITeacherDao
3）使用静态代理方式，就需要在代理对象TeacherDaoProxy中也实现ITeacherDao
4）调用的时候通过调用代理的方法调用目标对象
5）特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法
静态代理优缺点
1）优点：在不修改目标目录对象功能前提下，能通过代理对象对目标功能进行扩展
2）缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类
3）一旦接口增加方法；目标对象与代理对象都的维护
动态代理的基本介绍
1）代理对象不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
2）代理对象的生成，是利用JDK的API，动态的内存中构建代理对象
3）代理对象也叫：JDK代理或接口代理
JDK生成代理对象的API
1）代理类所在包：java.lang.reflect.Proxy
2)JDK实现代理只需要使用newProxyInstance方法，但是该方法需要接收三个参数，完整的写法是
static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces, InvocationHandler h)
getProxyInstance()
1)根据传入的对象（TeacherDao），目标对象
2）利用返回机制，返回一个代理对象
3）案后通过代理对象，调用目标对象方法
Cglib代理模式
1）静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只有一个单独的对象
并没有实现任何的接口，这个时候可使用目标对象子类来实现代理-这个就是Cglib代理
2）Cglib代理也叫做子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展，
有些书也叫Cglib代理归属到动态模式
3）Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口，它广泛的被许多
AOP的架构使用，例如Spring AOP，实现方法拦截
4）在AOP编程中如何选择代理模式：
1.目标对象需要实现接口，用JDK代理
2.目标对象不需要实现接口，用Cglib代理
5）Cglib包的底层是通过使用字节码代理框架ASM来转换字节码并生成新的类
代理模式的变种
1）防火墙代理
内网通过代理穿透防火墙，实现对公网的访问
2）缓存代理
比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则OK，如果取不到资源，则到公网或则数据库取，然后缓存
3）远程代理
远程对象的本地代表，通过它可以把远程对象当本地对象来调用，远程代理通过网络和真正的远程对象沟通信息
4）同步代理
主要使用到多线程编程中，完成多线程间同步工作

19 模版方法模式
包名：template
案例：编写制作豆浆的程序
1）制作豆浆的流程，选材->添加配料->浸泡->放到豆浆机打碎
2）通过添加不到的配料，可以制作出不同口味的豆浆
3）选材、浸泡和放在豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的（红豆、花生豆浆）
4）请使用模版方法模式完成（说明：因为模版方法模式，比较简单，很容易就想到这个方案，因此就直接使用，不再
使用传统的方案来引出模版方法模式）
模版方法模式的基本介绍
1）模版方法模式（Template Method Pattern），又叫模版模式（Template Pattern），
在一个抽象公开定义了执行它的方法的模版，它的子类可以按需要重写方法实现，但调用将以抽象类来定义的方式进行
2）简单说，模版方法模式定义一个操作来的计算的骨架，而将一个步骤延迟到子类中，使得子类可以不改变一个算法
的结构，就可以重定义该算法的某些特定步骤
3）这种类型的设计模式属于行为性模式
原理图分析
1）AbstractClass抽象类，类中实现了模版方法，定义了算法的骨架，具体的子类需要重新实现其他的抽象方法2、3、4
2）ConcreteClass实现抽象方法operation 2、3、4，以完成算法中完成特定的子类的步骤
模版方法模式的钩子方法
1）在模版方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要去覆盖它，该方法称为钩子
2）还是用上面做豆浆的例子来讲解，比如，我们还是希望制作纯豆浆，不添加任何的配料，请使用
钩子方法对前面的模版方法进行比较

20命令模式
包名：command
智能生活项目需求
1）我们买了一套智能家电，有照明灯，风扇、冰箱、洗衣机。我们只需要在手机上安装app就可以控制
对这些家电的工作
2）这些智能家电来自不同的工厂，我们不想针对每一种家电都安装一个app，分别控制，我们希望只要一个app
就可以控制智能家电
3）要实现一个app控制所有智能家电的需要，则每个智能家电厂商都需要提供一个统一的接口
给app调用，这时就可以考虑使用命令模式
4）命令模式可将动作的请求者从动作的执行者对象中解偶出来
5）在我们的例子中，动作的执行者是手机app，动作的执行者是每个厂商的一个家电产品
命令模式的基本介绍
1）在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪一个
我们只需在程序运行的时指定具体的请求接收者即可，此时，可是使用命令模式来进行设计
2）命令模式使得请求发送者与请求接收者取消彼此之间的耦合，让对象之间的调用关系更加灵活，实现解偶
3）在命令模式中，会将一个请求封装好的对象，以便使用不同参数来表达不同的请求（即命令），同时命令模式也支持可撤销的操作
4）通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色，将军（命令发布者）、士兵（命令的具体执行者）、命令（连接将军和士兵）
Invoker是调用者（将军），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象
命令模式的注意事项和细节
1）将发起请求的对象与执行请求的对象解偶。发起请求的对象的调用者，调用者只要调用命令对象的execute方法就可以让接收者工作，而不必知道
具体的接收者对象是谁，是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说“请求发起者”和“请求执行者”之间的
解偶是通过命令对象实现的，命令对象起到了纽带桥梁的作用
2）容易设计一个命令队列。只要把命令对象放到队列中，就可以多线程执行命令
3）容易实现对请求的撤销和重做
4）命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候需注意
5）空命令也是一种设计模式。它为我们省去了判空的操作，在上面的实例中，如果没有空命令，我们按下一个按键都要进行判空
这给我们编码带来一定的麻烦
6）命令模式经典的应用场景：界面的一个按钮就是一条命令、模拟CMD（DOS命令）订单的撤销和恢复，触发和反馈机制

21 访问者模式
包名：visitor
案例：
评测系统的需求
1）将人分为男人和女人，对歌手进行评测，当看完某个歌手表演后，得到他们对该歌手不同的评价
（评价 有不同的种类，比如 成功、失败等）
传统方式的问题解析
1）如果系统比较小，还是很ok的，但是考虑系统增加越来越新的功能时，对代码改动较大，违反了OCP原则
2）扩展性不好，比如，新增了新的人员类型，或者管理者方法，这就不好做了
访问者模式的基本介绍
1）封装一些作用于某些数据结构的各元素的操作，它可以在不改变数据结构的前提定义作用于这些元素的新的操作
2）主要是将数据结构和数据操作分离，解决数据结构和操作耦合性问题
3）访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口
4）访问者模式主要的应用场景是：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此之间没有关联），同时需要
避免让这些操作“污染”这些对象的类，可以选用访问者模式解决
访问者模式原理图
1）Visitor是一个抽象者，为该对象结构中的ConcreteElement的每一个类声明一个Visitor操作
2）ConcreteVisitor：是一个具体的访问者，实现每个有Visitor操作，是每个操作的实例部分
3）ObjectStructure：能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问它的元素
4）Element：定义了一个accept方法，可以接收一个访问者对象
5）ConcreteElement：为具体的元素，实现了accept方法
应用案例小结
-上面提到的双分派，所谓的双分派就是指不管类怎么变化，我们都能找到预期的方法运行
双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型
-以上述实例为例，假设我们要添加一个NotBat的状态类，考察Man和Woman类的反应
由于使用了双分派，只需增加一个Action的子类即可的客户端调用即可
不需要改动任何其他类的代码
访问者模式的注意事项和细节
优点
1）访问者模式符合单一职责原则，让程序具有优秀的扩展性，灵活性非常高
2）访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对问题的系统
缺点
1）具有元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，也即是迪米特法则所不建议的
这样造成了具体元素变更比较困难
2）违背了依赖倒置原则。访问者依赖的是具体元素，而不是抽象元素
3）因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的

22 迭代器模式
案例：
编写程序展示一个学院院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系
传统的方法的解决分析
1）将学院看做是学校的子类，系是学院的子类 ，这样实际上是站在组织大小来进行分层次的
2）实际上我们的需求是：在一个页面中展示出学院的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现
的遍历的操作
3）解决方案 => 迭代器迷失
迭代器的基本介绍
1）迭代器模式是常用的设计模式，属于行为型模式
2）如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类
或者还有其他方式，当客户端要遍历这些集合元素的时候就是使用多种遍历方式，而且还有暴露元素的内部结构，
可以考虑使用迭代器模式解决
3）迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示
即：不暴露内部的结构
迭代器模式的结构图解析
1）Iterator：迭代器接口，是系统提供，包含：hasNext，next，remove
2）ConcreteIterator：具体的迭代器类，管理迭代
3）Aggregate:一个统一的聚合接口，将客户端和具体聚合解偶
4）ConcreteAggregate：具体的聚合持有对象集合，并提供一个方法，返回一个迭代器
该迭代器可以正确遍历集合
5）Client：客户端，通过Iterator和Aggregate依赖子类
迭代器模式的注意事项和细节
优点
1）提供一个统一的方法遍历对象，客户不需要考虑聚合的类型，使用一种方法就可以遍历对象
2）隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取出迭代器，而不会知道聚合的具体组成
3）提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一职责原则）。在聚合类中
我们把迭代器分开，这样以来集合改变的话，只影响到聚合对象，而如果遍历方式改变的话，只影响到了迭代器
4）当要展示一组相似对象，或者遍历一组相同对象时使用，适合使用迭代器模式
缺点
每个聚合对象都要一个迭代器，会产生多个迭代器不好管理类

23 观察者模式
包名：observer
案例
天气预报项目需求，具体要求如下：
1）气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出来（
比如发布了自己的网站或第三方）
2）需要设计开放型API，便于其他第三方也能接入气象站获取数据
3）提取温度，气压和湿度的接口
4）测量数据更新时，要能实时的通知给第三方
普通方案
WeatherData类
通过对气象项目的分析，我们可以初步设计出一个WeatherData类
说明：
1）通过getXXX方法，可以让第三方接入，并得到相关信息
2）当数据有更新时，气象站通过调用dataChange去更新数据，当第三方再次获取时，就能得到最新数据，当然可以推送
问题分析
1）其他第三方接入气象站获取数据的问题
2）无法在运行时动态的添加第三方（新浪微博）
3）违反了OCP => 观察者模式
//在WeatherData中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到dataChange，不利于维护，也不是动态添加



