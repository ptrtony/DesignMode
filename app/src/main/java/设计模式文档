1 单一职责原则
包名：singleResponsibility
单一职责原则注意事项和细节
1)、降低类的复杂度，一个类只负责一项职责
2)、提高类的可读性，可维护性
3)、降低变更引起的风险
4)、通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则：
只有类中方法数量足够少，可以在方法级别保持单一职责原则

2 接口隔离原则
包名interface_segregation_principle
基本介绍
1)、客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖
应该建立在最小的接口上
2)、类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口
Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法
3)、按隔离原则应当这样处理：
将接口interface拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。
1)、类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说
不是最小接口，那么类B和类D必须去实现他们不需要的方法
2)、将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则
3)、接口Interface1中出现的方法，根据实际情况拆分为三个接口
4)、代码实现

3 依赖倒置原则
包名：dependence_inversion_principle
1)、高层模块不应该依赖底层模块，二者都应该依赖其抽象
2)、抽象不应该依赖细节，细节应该依赖与抽象
3)、依赖倒转(倒置)的中心思想是面向接口编程
4)、依赖倒转原则是基于这样的设计理念，相当于细节的多变性，抽象的东西要稳定的多
以抽象为基础搭建的架构比以细节为基础的架构要稳定的多，在java中，抽象指的是接口或抽象类，细节
就是具体的实现类
5)、使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成
实现方式：
1)、接口传递（应用案例代码）
2)、构造方法传递（应用案例代码）
3)、setter方式传递

4里氏替换原则
包名：liskov
00中的继承性的思考和说明
1)、继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制
要求所有的子类必须遵循这个契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承造成破坏。
2)、继承再给程序设计带来便利的同时，也带来弊端，比如使用继承会给程序带来侵入性，程序的可移植降低，
增加对对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且
父类修改后，所有涉及到子类的功能都有可能产生故障
3)、问题提出：在编程中，如何正确的使用继承?=>里氏替换原则
里氏替换原则是：
1）、如果对每个类型为T1的对象o1，都有类型为T2的对象O2，使得以T1定义的所有程序P在所有的对象O1
都代换成O2时，程序P的行为没有发生改变，那么类型T2是类型T1的子类型，。换句话说，所有引用基类的地方
必须能透明的使用其子类的对象
2)、在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类方法
3)、里氏替换原则告诉我们，继承实际上让两个类耦合性增强，在合适的情况下，可以通过聚合，组合，依赖来解决问题

5开闭原则
包名：open_close
1)、开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则
2)、一个软件实体如类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节
3)、当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化
4)、编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。
思路：把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可，这样我们有新的图形
种类时，只需要让新的图形类继承Shape。并实现draw方法即可。

6迪米特法则
包名：demeter
1)、一个对象应该对其他对象保持最小的了解
2)、类与类关系越密切，耦合度越大
3)、迪米特法则(Demeter principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，也就是说
对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供一个public方法，不对外泄漏任何信息
4)、迪米特法则还是个更简单的定义，只与直接的朋友通讯
5)、直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间时朋友关系，耦合
的方式更多，依赖、关联、组合、聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接朋友，而出现
在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

7合成复用原则
原则是尽量使用合并/聚合的方式，而不是使用继承
设计原则核心思想
1)、找出应用中可能需要变化之处，把它们独立起来，不要和哪些不需要变化的代码混在一起
2)、针对接口编程，而不是针对实现编程
3)、为了交互对象之间的松耦合设计而努力

8单利模式
所谓类的单利模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，
并且该类只提供一个取得其对象实例的方法
比如Hibernate的sessionFactory，它充当数据存储源的代理，并负责创建Session对象，SessionFactory
并不是轻量级的，一般情况下，一个项目通常只需要以恶搞SessionFactory就够，就是就会使用到单例模式
单例模式的八种写法
1)、饿汉式（静态常量）
2)、饿汉式（静态代码块）
3)、懒汉式（线程不安全）
4)、懒汉式（线程安全、同步方法）
5)、懒汉式（线程安全、同步代码块）
6)、双重校验
7)、静态内部类
8)、枚举
饿汉式（静态常量）应用实例
步骤如下：
1)、构造器私有化（防止new）
2)、类的内部创建对象
3)、向外暴露一个静态的公共方法。getInstance
4)、代码实现
优缺点说明：
饿汉式（静态常量）、饿汉式（静态代码块）
Singleton01、Singleton02
1）优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题
2) 缺点：在类装载的时候就完成实例化，没有达到Lazy loading的效果。如果从始至终从未
使用过这个实例，则会造成内存的浪费
3)这种方式基于classloader机制避免了多线程的同步问题。不过，instance在类装载时就
实例化了，在单例模式大多数就是调用getInstance()方法，但是导致类装载的原因有很多种
因此不能确定有其他的方式（或则其他的静态方法）导致类的装载，这时候初始化instance
就没有达到lazy loading的效果
4）结论：这种单例模式可用，可能造成内存浪费
懒汉式（线程不安全）
Singleton03
优缺点
1）、起到了Lazy loading的效果，但是只是在单线程中使用
2）、如果在多线程下，一个线程进入到if(singleton == null) 代码块中
还未来得及往下执行，另一个线程也通过了这个判断条件。这时便会产生多个实例。
所以在多线程环境下不可使用这种方式
3）、结论：在实际的开发中，不要使用这种方式。
懒汉式（线程安全）
Singleton04
优缺点
1）、解决了线程不安全问题
2）、效率太低了，每个线程在想获得类的实例的时候，执行getInstance（）方法都要进行
同步。而其实这个方法只执行了一次实例化代码就够了，后面的想获得该类实例，直接return就行了。
方法进行同步效率太低
3）、结论：在实际的开发中，不推荐使用这种方式。
Singleton05
优缺点
1）、这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，
改为同步产生实例化的代码块
2）、但是这种同步并不能起到线程同步的作用。跟第三种实现方法遇到的情形一致，假如
一个线程进入了if（singleton == null）判断代码块中，还未来得及往下执行，
另一个线程也通过了这个判断语句，这种会产生多个实例。
3）、结论：在实际开发中，不能使用这种方式。
Singleton06
双重检查

Singleton07
优缺点
1）、这种方式采用了类装载机制来保证初始化实例时只有一个线程
2）、静态内部类方法在Singleton类被装载时并不会立即被实例化，而是在需要实例化时，调用
getInstance方法，不会装载SingletonInstance类，而是完成Singleton的实例化
3）、类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程安全
性，在类进行初始化时，别的线程是无法进入的
4）、优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高

9工厂模式
简单工厂模式
1）、简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定
创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式
2）、简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）
3）、在软件开发中，当我们会用到大量的创建某种、某类或则某批对象时，就会使用到工厂模式
工厂方法模式
使用简单工厂模式，创建不同的简单工厂模式，比如BJPizzaSimpleFactory、
LDPizzaSimpleFactory等等，从当前这个案例来说，也是可以的，但是考虑到项目的规模
以及软件的可维护性，可扩展性并不是特别好
思路
使用工厂方法模式
包名：factory/method
工厂方式模式介绍
工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现
工厂方法模式：定义一个创建的抽象方法，由子类决定要实例化的类。工厂方法模式将抽象的实例化推迟给子类。
抽象工厂模式
包名：factory/abs
抽象工厂模式：
1）、定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
2）、抽象工厂模式可以将简单的工厂模式和工厂方法整合
3）、从设计层面看，抽象工厂模式就是对简单的工厂模式的改进（或者称为进一步的抽象）
4）、将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用
对应的工厂子类。这样将单个的简单工厂类变成了工厂簇；便利于代码的维护和扩展


